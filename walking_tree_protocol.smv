MODULE main
    VAR
        -- Reader is shared among the tags
        t1 : tag(r);    
        t2 : tag(r);
        t3 : tag(r);
        t4 : tag(r);
        r : reader(t1, t2, t3, t4);
    -- Exclusivity condition: checks if AT LEAST two tags are capable of transmitting simultaneously
    -- This needs to be false
    CTLSPEC
    EF  ((t1.state = transmit & t2.state = transmit) |
         (t1.state = transmit & t3.state = transmit) |
         (t1.state = transmit & t4.state = transmit) |
         (t2.state = transmit & t3.state = transmit) |
         (t2.state = transmit & t4.state = transmit) |
         (t3.state = transmit & t4.state = transmit) )

    -- Exclusivity condition: checks that the previous condition is respected
    CTLSPEC
    AG  (!(t1.state = transmit & t2.state = transmit) &
         !(t1.state = transmit & t3.state = transmit) &
         !(t1.state = transmit & t4.state = transmit) &
         !(t2.state = transmit & t3.state = transmit) &
         !(t2.state = transmit & t4.state = transmit) &
         !(t3.state = transmit & t4.state = transmit) )

    -- Checks that every round is capable of making each tag transmit its message 
    CTLSPEC
    AG EF((t1.state=transmitted) & (t2.state=transmitted) & (t3.state=transmitted) & (t4.state=transmitted))

    -- Similar to above, checks that the reader is capable of finishing the round
    CTLSPEC
    AG AF (r.state=completed)

    -- Checks if a tag always has the capacity to transmit a message given a request to send.
    -- The same is applied to all tags.
    CTLSPEC
    AG ((t1.state=request) -> AF (t1.state=transmit))
    CTLSPEC
    AG ((t2.state=request) -> AF (t2.state=transmit))
    CTLSPEC
    AG ((t3.state=request) -> AF (t3.state=transmit))
    CTLSPEC
    AG ((t4.state=request) -> AF (t4.state=transmit))

    -- Checks that if each tag has transmitted, the round ends.
    LTLSPEC
    G F(((t1.state=transmitted) & (t2.state=transmitted) & (t3.state=transmitted) & (t4.state=transmitted)) -> G F(r.state=completed))

MODULE tag(reader)
    VAR
    state:  {idle,          -- Initial state, not requesting to transmit.
             request,       -- State in which the tag asks the reader to transmit.
             wait,          -- State in which the tag hasn't transmitted its message and is waiting to flip another coin.
             transmit,      -- Critical state of transmission, exclusivity is mandatory.
             transmitted};  -- State in which the tag has transmitted its message and is waiting for the next round.
    
    ASSIGN
        init(state) := idle; -- Sets the initial state, in which the round has just started.

        next(state) :=
            case
                -- When in the initial state, immediately try to send a message.
                state = idle                                        : request;
                -- If there are multiple tags requesting to send, flip a coin.
                -- If heads, keep requesting.
                -- If tails, start waiting and move yourself out of the queue.
                state = request   & reader.state = collision        : {request, wait};
                -- If there is a single tag requesting to send, send a message.
                state = request   & reader.state = notCollision     : transmit;
                -- Extra state in which the tag is transmitting, useful to indicate that transmission takes up some time.
                state = transmit  & reader.state = receiving        : transmitted;
                -- If the round has ended, restart the cycle by putting yourself on idle. 
                -- Despite reader.state = completed only being true if state = transmitted, having both conditions allows 
                -- for better readability.
                state = transmitted  & reader.state = completed     : idle;
                -- If out of the transmission queue and the reader is done receiving the message put yourself back in the queue.
                state = wait      & reader.state = free             : request;
                -- Default case, state remains the same.
                TRUE : state;
            esac;

MODULE reader(t1, t2, t3, t4)
    VAR
        state : {idle,          -- Initial state, reader doesn't know how many tags are transmitting.
                 collision,     -- Collision state in which the number of readers is > 1.
                 notCollision,  -- State in which there isn't a collision, number of readers = 0.
                 receiving,     -- State in which the tag is transmitting and the reader is busy, also shows that receiving takes up some time.
                 free,          -- State in which all the conflicting tags - 1 were put in a queue and the last remaining tag was allowed to transmit.
                 completed};    -- State that signals the end of the round.
    
    ASSIGN
        init(state) := idle;    -- Initial state, in which the round has just started.

        next(state) :=
            case 
                -- If there are at least two tags requesting to transmit, go in the collision state and ask the tags to flip a coin.
                state=idle &    ((t1.state=request & t2.state=request)    | 
                                 (t1.state=request & t3.state=request)    | 
                                 (t1.state=request & t4.state=request)    | 
                                 (t2.state=request & t3.state=request)    |
                                 (t2.state=request & t4.state=request)    |
                                 (t3.state=request & t4.state=request))   : collision;
                
                -- Case in which the only tag in the queue is requesting to transmit, collision isn't present here.
                state=collision & (t1.state=request                       & 
                                   (t2.state=wait | t2.state=transmitted) & 
                                   (t3.state=wait | t3.state=transmitted) & 
                                   (t4.state=wait | t4.state=transmitted)): notCollision;

                -- Case in which the only tag in the queue is requesting to transmit, collision isn't present here.
                state=collision & ((t1.state=wait | t1.state=transmitted) & 
                                   t2.state=request                       & 
                                   (t3.state=wait | t3.state=transmitted) & 
                                   (t4.state=wait | t4.state=transmitted)): notCollision;

                -- Case in which the only tag in the queue is requesting to transmit, collision isn't present here.
                state=collision & ((t1.state=wait | t1.state=transmitted) &
                                   (t2.state=wait | t2.state=transmitted) & 
                                   t3.state=request                       & 
                                   (t4.state=wait | t4.state=transmitted)): notCollision;

                -- Case in which the only tag in the queue is requesting to transmit, collision isn't present here.
                state=collision & ((t1.state=wait | t1.state=transmitted) &
                                   (t2.state=wait | t2.state=transmitted) & 
                                   (t3.state=wait | t3.state=transmitted) & 
                                   t4.state=request)                      : notCollision;
                
                -- Case in which all readers have put themselves in the queue or have already transmitted,
                -- makes the remaining tags put themselves back in the queue.
                -- No need to check that all the states have transmitted, 
                -- as having a collision requires that there was at least one tag requesting.
                state=collision & ((t1.state=wait | t1.state=transmitted) & 
                                   (t2.state=wait | t2.state=transmitted) &
                                   (t3.state=wait | t3.state=transmitted) & 
                                   (t4.state=wait | t4.state=transmitted)): free;
                                      
                -- Case in which a collision isn't present and only one tag is asking to send. In such a case, start receiving.
                state=notCollision & (t1.state = request  & (t2.state = transmitted | t2.state = wait) & (t3.state = transmitted | t3.state = wait) & (t4.state = transmitted | t4.state = wait)) : receiving;
                -- Case in which a collision isn't present and only one tag is asking to send. In such a case, start receiving.
                state=notCollision & ((t1.state = transmitted | t1.state = wait) & t2.state = request  & (t3.state = transmitted | t3.state = wait) & (t4.state = transmitted | t4.state = wait)) : receiving;
                -- Case in which a collision isn't present and only one tag is asking to send. In such a case, start receiving.
                state=notCollision & ((t1.state = transmitted | t1.state = wait) & (t2.state = transmitted | t2.state = wait) & t3.state = request  & (t4.state = transmitted | t4.state = wait)) : receiving;
                -- Case in which a collision isn't present and only one tag is asking to send. In such a case, start receiving.
                state=notCollision & ((t1.state = transmitted | t1.state = wait) & (t2.state = transmitted | t2.state = wait) & (t3.state = transmitted | t3.state = wait) & t4.state = request)  : receiving;
                
                -- Case in which the reader is receiving and the tag is the only one transmitting, communication is successful.
                state=receiving & (t1.state = transmit) : free;
                -- Case in which the reader is receiving and the tag is the only one transmitting, communication is successful.
                state=receiving & (t2.state = transmit) : free;
                -- Case in which the reader is receiving and the tag is the only one transmitting, communication is successful.
                state=receiving & (t3.state = transmit) : free;
                -- Case in which the reader is receiving and the tag is the only one transmitting, communication is successful.
                state=receiving & (t4.state = transmit) : free;

                -- Case in which every tag has transmitted, the receiver signals that the round is over.
                state=idle & ((t1.state=transmitted) & (t2.state=transmitted) & (t3.state=transmitted) & (t4.state=transmitted)) : completed;

                -- Case that allows tags to put themselves back in the queue, the round is not over.
                state=free : idle;

                -- Case that allows tags to put themselves back in the starting state.
                state=completed : idle;  

                -- Default case, state remains the same.
                TRUE : state;
            esac;